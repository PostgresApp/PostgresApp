--- configure.in.orig	2013-12-02 21:57:48.000000000 +0100
+++ configure.in	2014-02-10 14:43:51.000000000 +0100
@@ -680,6 +680,16 @@
 AC_MSG_RESULT([$with_selinux])
 
 #
+# ICU
+#
+AC_MSG_CHECKING([whether to build with ICU support])
+PGAC_ARG_BOOL(with, icu, no, [  --with-icu              build with ICU support],
+              [AC_DEFINE([USE_ICU], 1, [Define to build with ICU support. (--with-icu)])])
+AC_MSG_RESULT([$with_icu])
+AC_SUBST(with_icu)
+
+
+#
 # Readline
 #
 PGAC_ARG_BOOL(with, readline, yes,
@@ -948,6 +958,51 @@
   fi
 fi
 
+if test "$with_icu" = yes ; then
+ AC_CHECK_LIB(icui18n, ucol_open_54, [], [
+ AC_CHECK_LIB(icui18n, ucol_open_53, [], [
+ AC_CHECK_LIB(icui18n, ucol_open_52, [], [
+  AC_CHECK_LIB(icui18n, ucol_open_50, [], [
+   AC_CHECK_LIB(icui18n, ucol_open_48, [], [
+    AC_CHECK_LIB(icui18n, ucol_open_46, [], [
+      AC_CHECK_LIB(icui18n, ucol_open_44, [], [
+        AC_CHECK_LIB(icui18n, ucol_open_43, [], [
+          AC_CHECK_LIB(icui18n, ucol_open_3_8, [], [
+            AC_CHECK_LIB(icui18n, ucol_open_3_6, [], [
+              AC_CHECK_LIB(icui18n, ucol_open_3_4, [], [AC_MSG_ERROR([library 'icui18n' is required for ICU])])
+            ])
+          ])
+        ])
+      ])
+    ])
+   ])
+  ])
+ ])
+ ])
+ ])
+ AC_CHECK_LIB(icuuc, ucnv_fromUChars_54, [], [
+ AC_CHECK_LIB(icuuc, ucnv_fromUChars_53, [], [
+ AC_CHECK_LIB(icuuc, ucnv_fromUChars_52, [], [
+  AC_CHECK_LIB(icuuc, ucnv_fromUChars_50, [], [
+   AC_CHECK_LIB(icuuc, ucnv_fromUChars_48, [], [
+    AC_CHECK_LIB(icuuc, ucnv_fromUChars_46, [], [
+      AC_CHECK_LIB(icuuc, ucnv_fromUChars_44, [], [
+        AC_CHECK_LIB(icuuc, ucnv_fromUChars_43, [], [
+          AC_CHECK_LIB(icuuc, ucnv_fromUChars_3_8, [], [
+            AC_CHECK_LIB(icuuc, ucnv_fromUChars_3_6, [], [
+              AC_CHECK_LIB(icuuc, ucnv_fromUChars_3_4, [], [AC_MSG_ERROR([library 'icuuc' is required for ICU])])
+            ])
+          ])
+        ])
+      ])
+    ])
+   ])
+  ])
+ ])
+ ])
+ ])
+fi
+
 if test "$with_pam" = yes ; then
   AC_CHECK_LIB(pam,    pam_start, [], [AC_MSG_ERROR([library 'pam' is required for PAM])])
 fi
@@ -1066,6 +1113,10 @@
   AC_CHECK_HEADER(openssl/err.h, [], [AC_MSG_ERROR([header file <openssl/err.h> is required for OpenSSL])])
 fi
 
+if test "$with_icu" = yes ; then
+  AC_CHECK_HEADER(unicode/utypes.h, [], [AC_MSG_ERROR([header file <unicode/utypes.h> is required for ICU])])
+fi
+
 if test "$with_pam" = yes ; then
   AC_CHECK_HEADERS(security/pam_appl.h, [],
                    [AC_CHECK_HEADERS(pam/pam_appl.h, [],
--- src/backend/utils/adt/formatting.c	2011-09-08 23:13:27.000000000 +0200
+++ src/backend/utils/adt/formatting.c	2011-09-22 18:05:26.678417883 +0200
@@ -92,6 +92,12 @@
 #include "utils/numeric.h"
 #include "utils/pg_locale.h"
 
+#ifdef USE_ICU
+#include <unicode/utypes.h>   /* Basic ICU data types */
+#include <unicode/ucnv.h>     /* C   Converter API    */
+#include <unicode/ustring.h>
+#endif /* USE_ICU */
+
 /* ----------
  * Routines type
  * ----------
@@ -942,6 +948,12 @@
 } NUMProc;
 
 
+#ifdef USE_ICU
+static UConverter *conv = NULL;
+#define STACKBUFLEN		1024 / sizeof(UChar)
+#endif   /* USE_ICU */
+
+
 /* ----------
  * Functions
  * ----------
@@ -1498,6 +1510,82 @@
 		for (p = result; *p; p++)
 			*p = pg_ascii_tolower((unsigned char) *p);
 	}
+#ifdef USE_ICU
+	/* use ICU only when max encoding length > one */
+	if (pg_database_encoding_max_length() > 1)
+	{
+		UChar       sourcebuf[STACKBUFLEN], destbuf[STACKBUFLEN];
+		UChar      *source, *dest;
+		int			buflen;
+		size_t		result_size, usize;
+		UErrorCode  status = U_ZERO_ERROR;
+
+		if (conv == NULL)
+		{
+			conv = ucnv_open(NULL, &status);
+			if (U_FAILURE(status))
+			{
+				ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: oracle_compat.c, could not get converter for \"%s\"", ucnv_getDefaultName())));
+			}
+		}
+
+		if (nbytes >= STACKBUFLEN / sizeof(UChar))
+		{
+			buflen = (nbytes + 1) * sizeof(UChar);
+ 			source = palloc(buflen);
+			dest = palloc(buflen);
+		}
+		else
+		{
+			buflen = STACKBUFLEN;
+			source = sourcebuf;
+			dest = destbuf;
+		}
+		// convert to UTF-16
+		ucnv_toUChars(conv, source, buflen, buff, nbytes, &status);
+		if (U_FAILURE(status))
+		{
+			ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: Could not convert string")));
+		}
+		
+		// run desired function
+		buflen = u_strToLower(dest, buflen, source, -1, NULL, &status);
+		if (U_FAILURE(status))
+		{
+			ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: Could not modify case")));
+		}
+
+		// and convert modified utf-16 string back to text
+		result_size = UCNV_GET_MAX_BYTES_FOR_STRING(buflen, ucnv_getMaxCharSize(conv));
+		result = palloc(result_size);
+
+		usize = ucnv_fromUChars(conv, result, result_size,
+								 dest, buflen, &status);
+
+		if (U_FAILURE(status))
+		{
+			/* Invalid multibyte character encountered ... shouldn't happen */
+			ereport(ERROR,
+					(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),
+					 errmsg("ICU: invalid multibyte character for locale")));
+		}
+
+		Assert(usize <= (size_t) (buflen * sizeof(UChar)));
+
+		if (nbytes >= STACKBUFLEN / sizeof(UChar))
+		{
+			pfree(source);
+			pfree(dest);
+		}
+		return result;
+	}
+#else
 #ifdef USE_WIDE_UPPER_LOWER
 	else if (pg_database_encoding_max_length() > 1)
 	{
@@ -1551,6 +1639,7 @@
 		pfree(workspace);
 	}
 #endif   /* USE_WIDE_UPPER_LOWER */
+#endif   /* USE_ICU */
 	else
 	{
 		pg_locale_t mylocale = 0;
@@ -1619,6 +1708,82 @@
 		for (p = result; *p; p++)
 			*p = pg_ascii_toupper((unsigned char) *p);
 	}
+#ifdef USE_ICU
+	/* use ICU only when max encoding length > one */
+	if (pg_database_encoding_max_length() > 1)
+	{
+		UChar       sourcebuf[STACKBUFLEN], destbuf[STACKBUFLEN];
+		UChar      *source, *dest;
+		int			buflen;
+		size_t		result_size, usize;
+		UErrorCode  status = U_ZERO_ERROR;
+
+		if (conv == NULL)
+		{
+			conv = ucnv_open(NULL, &status);
+			if (U_FAILURE(status))
+			{
+				ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: oracle_compat.c, could not get converter for \"%s\"", ucnv_getDefaultName())));
+			}
+		}
+
+		if (nbytes >= STACKBUFLEN / sizeof(UChar))
+		{
+			buflen = (nbytes + 1) * sizeof(UChar);
+ 			source = palloc(buflen);
+			dest = palloc(buflen);
+		}
+		else
+		{
+			buflen = STACKBUFLEN;
+			source = sourcebuf;
+			dest = destbuf;
+		}
+		// convert to UTF-16
+		ucnv_toUChars(conv, source, buflen, buff, nbytes, &status);
+		if (U_FAILURE(status))
+		{
+			ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: Could not convert string")));
+		}
+		
+		// run desired function
+		buflen = u_strToUpper(dest, buflen, source, -1, NULL, &status);
+		if (U_FAILURE(status))
+		{
+			ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: Could not modify case")));
+		}
+
+		// and convert modified utf-16 string back to text
+		result_size = UCNV_GET_MAX_BYTES_FOR_STRING(buflen, ucnv_getMaxCharSize(conv));
+		result = palloc(result_size);
+
+		usize = ucnv_fromUChars(conv, result, result_size,
+								 dest, buflen, &status);
+
+		if (U_FAILURE(status))
+		{
+			/* Invalid multibyte character encountered ... shouldn't happen */
+			ereport(ERROR,
+					(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),
+					 errmsg("ICU: invalid multibyte character for locale")));
+		}
+
+		Assert(usize <= (size_t) (buflen * sizeof(UChar)));
+
+		if (nbytes >= STACKBUFLEN / sizeof(UChar))
+		{
+			pfree(source);
+			pfree(dest);
+		}
+		return result;
+	}
+#else
 #ifdef USE_WIDE_UPPER_LOWER
 	else if (pg_database_encoding_max_length() > 1)
 	{
@@ -1672,6 +1837,7 @@
 		pfree(workspace);
 	}
 #endif   /* USE_WIDE_UPPER_LOWER */
+#endif   /* USE_ICU */
 	else
 	{
 		pg_locale_t mylocale = 0;
@@ -1752,6 +1918,82 @@
 						(c >= '0' && c <= '9'));
 		}
 	}
+#ifdef USE_ICU
+	/* use ICU only when max encoding length > one */
+	if (pg_database_encoding_max_length() > 1)
+	{
+		UChar       sourcebuf[STACKBUFLEN], destbuf[STACKBUFLEN];
+		UChar      *source, *dest;
+		int			buflen;
+		size_t		result_size, usize;
+		UErrorCode  status = U_ZERO_ERROR;
+
+		if (conv == NULL)
+		{
+			conv = ucnv_open(NULL, &status);
+			if (U_FAILURE(status))
+			{
+				ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: oracle_compat.c, could not get converter for \"%s\"", ucnv_getDefaultName())));
+			}
+		}
+
+		if (nbytes >= STACKBUFLEN / sizeof(UChar))
+		{
+			buflen = (nbytes + 1) * sizeof(UChar);
+			source = palloc(buflen);
+			dest = palloc(buflen);
+		}
+		else
+		{
+			buflen = STACKBUFLEN;
+			source = sourcebuf;
+			dest = destbuf;
+		}
+		// convert to UTF-16
+		ucnv_toUChars(conv, source, buflen, buff, nbytes, &status);
+		if (U_FAILURE(status))
+		{
+			ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: Could not convert string")));
+		}
+		
+		// run desired function
+		buflen = u_strToTitle(dest, buflen, source, -1, NULL, NULL, &status);
+		if (U_FAILURE(status))
+		{
+			ereport(ERROR,
+						(errcode(status),
+						 errmsg("ICU error: Could not modify case")));
+		}
+
+		// and convert modified utf-16 string back to text
+		result_size = UCNV_GET_MAX_BYTES_FOR_STRING(buflen, ucnv_getMaxCharSize(conv));
+		result = palloc(result_size);
+
+		usize = ucnv_fromUChars(conv, result, result_size,
+								 dest, buflen, &status);
+
+		if (U_FAILURE(status))
+		{
+			/* Invalid multibyte character encountered ... shouldn't happen */
+			ereport(ERROR,
+					(errcode(ERRCODE_CHARACTER_NOT_IN_REPERTOIRE),
+					 errmsg("ICU: invalid multibyte character for locale")));
+		}
+
+		Assert(usize <= (size_t) (buflen * sizeof(UChar)));
+
+		if (nbytes >= STACKBUFLEN / sizeof(UChar))
+		{
+			pfree(source);
+			pfree(dest);
+		}
+		return result;
+	}
+#else
 #ifdef USE_WIDE_UPPER_LOWER
 	else if (pg_database_encoding_max_length() > 1)
 	{
@@ -1817,6 +2059,7 @@
 		pfree(workspace);
 	}
 #endif   /* USE_WIDE_UPPER_LOWER */
+#endif   /* USE_ICU */
 	else
 	{
 		pg_locale_t mylocale = 0;
--- src/backend/utils/adt/varlena.c	2011-09-08 23:13:27.000000000 +0200
+++ src/backend/utils/adt/varlena.c	2011-09-22 18:00:26.135296062 +0200
@@ -30,6 +30,15 @@
 #include "utils/lsyscache.h"
 #include "utils/pg_locale.h"
 
+#ifdef USE_ICU
+#include <unicode/utypes.h>   /* Basic ICU data types */
+#include <unicode/ucnv.h>     /* C   Converter API    */
+#include <unicode/ucol.h>
+#include <unicode/uloc.h>
+#include "unicode/uiter.h"
+#define USTACKBUFLEN		STACKBUFLEN / sizeof(UChar)
+#endif /* USE_ICU */
+
 
 /* GUC variable */
 int			bytea_output = BYTEA_OUTPUT_HEX;
@@ -1295,6 +1304,134 @@
 	{
 #define STACKBUFLEN		1024
 
+#ifdef USE_ICU
+
+		if (pg_database_encoding_max_length() > 1)
+		{
+			static UCollator * collator = NULL;
+			UErrorCode  status = U_ZERO_ERROR;
+
+			/* We keep a static collator "forever", since it is hard
+			 * coded into the database cluster at initdb time
+			 * anyway. Create it first time we get here. */
+			if (collator == NULL)
+			{
+				/* Expect LC_COLLATE to be set to something that ICU
+				 * will understand. This is quite probable, since ICU
+				 * does a lot of heuristics with this argument. I'd
+				 * rather set this in xlog.c, but it seems ICU forgets
+				 * it??? */
+				uloc_setDefault(setlocale(LC_COLLATE, NULL), &status);
+				if(U_FAILURE(status))
+				{
+					ereport(WARNING,
+							(errcode(status),
+							 errmsg("ICU Error: varlena.c, could not set default lc_collate")));
+				}
+				collator = ucol_open(NULL, &status);
+				if (U_FAILURE(status))
+				{
+					ereport(WARNING,
+							(errcode(status),
+							 errmsg("ICU Error: varlena.c, could not open collator")));
+				}
+			}
+			
+			if (GetDatabaseEncoding() == PG_UTF8)
+			{
+				UCharIterator sIter, tIter;
+				uiter_setUTF8(&sIter, arg1, len1);
+				uiter_setUTF8(&tIter, arg2, len2);
+				result = ucol_strcollIter(collator, &sIter, &tIter, &status);
+				if (U_FAILURE(status))
+				{
+					ereport(WARNING,
+							(errcode(status),
+							 errmsg("ICU Error: varlena.c, could not collate")));
+				}
+			}
+			else {
+				/* We keep a static converter "forever". 
+				 * Create it first time we get here. */
+				static UConverter * conv = NULL;
+				if (conv == NULL)
+				{
+					conv = ucnv_open(NULL, &status);
+					if (U_FAILURE(status) || conv == NULL)
+					{
+						ereport(ERROR,
+								(errcode(status),
+								 errmsg("ICU error: varlena.c, could not get converter for \"%s\"", ucnv_getDefaultName())));
+					}
+				}
+
+				UChar	a1buf[USTACKBUFLEN],
+						a2buf[USTACKBUFLEN];
+				int		a1len = USTACKBUFLEN,
+			  			a2len = USTACKBUFLEN;	
+				UChar	*a1p,
+						*a2p;
+				if (len1 >= USTACKBUFLEN / sizeof(UChar))
+				{
+					a1len = (len1 + 1) * sizeof(UChar);
+					a1p = (UChar *) palloc(a1len);	
+				}
+				else
+					a1p = a1buf;
+
+				if (len2 >= USTACKBUFLEN / sizeof(UChar))
+				{
+					a2len = (len2 + 1) * sizeof(UChar);
+					a2p = (UChar *) palloc(a2len);
+				}
+				else
+					a2p = a2buf;
+
+				ucnv_toUChars(conv, a1p, a1len, arg1, len1, &status);
+				if(U_FAILURE(status))
+				{
+					ereport(WARNING,
+							(errcode(status),
+							 errmsg("ICU Error: varlena.c, could not convert to UChars")));
+				}
+				ucnv_toUChars(conv, a2p, a2len, arg2, len2, &status);
+				if(U_FAILURE(status))
+				{
+					ereport(WARNING,
+							(errcode(status),
+							 errmsg("ICU Error: varlena.c, could not convert to UChars")));
+				}
+
+				result = ucol_strcoll(collator, a1p, -1, a2p, -1);
+				if(U_FAILURE(status))
+				{
+					ereport(WARNING,
+							(errcode(status),
+							 errmsg("ICU Error: varlena.c, could not collate")));
+				}
+				if (len1 * sizeof(UChar) >= USTACKBUFLEN)
+					pfree(a1p);
+				if (len2 * sizeof(UChar) >= USTACKBUFLEN)
+					pfree(a2p);
+			}
+			/*
+			 * In some locales wcscoll() can claim that nonidentical strings
+			 * are equal.  Believing that this might be so also for ICU, and
+			 * believing that would be bad news for a number of
+			 * reasons, we follow Perl's lead and sort "equal" strings
+			 * according to strcmp (on the byte representation).
+			 */
+			if (result == 0)
+			{
+				result = strncmp(arg1, arg2, Min(len1, len2));
+				if ((result == 0) && (len1 != len2))
+					result = (len1 < len2) ? -1 : 1;
+			}
+
+			return result;
+		}
+#endif /* USE_ICU */
+
 		char		a1buf[STACKBUFLEN];
 		char		a2buf[STACKBUFLEN];
 		char	   *a1p,
--- src/backend/utils/mb/encnames.c	2011-09-08 23:13:27.000000000 +0200
+++ src/backend/utils/mb/encnames.c	2011-09-22 18:00:26.136299541 +0200
@@ -394,6 +394,118 @@
 };
 
 
+#ifdef USE_ICU
+/*
+ * Try to map most internal character encodings to the proper and
+ * preferred IANA string. Use this in mbutils.c to feed ICU info about
+ * the database's character encoding.
+ *
+ * Palle Girgensohn, 2005
+ */
+
+pg_enc2name pg_enc2iananame_tbl[] =
+{
+	{
+		"US-ASCII", PG_SQL_ASCII
+	},
+	{
+		"EUC-JP", PG_EUC_JP
+	},
+	{
+		"GB2312", PG_EUC_CN
+	},
+	{
+		"EUC-KR", PG_EUC_KR
+	},
+	{
+		"ISO-2022-CN", PG_EUC_TW
+	},
+	{
+		"KS_C_5601-1987", PG_JOHAB  /* either KS_C_5601-1987 or ISO-2022-KR ??? */
+	},
+	{
+		"UTF-8", PG_UTF8
+	},
+	{
+		"MULE_INTERNAL", PG_MULE_INTERNAL  /* is not for real */
+	},
+	{
+		"ISO-8859-1", PG_LATIN1
+	},
+	{
+		"ISO-8859-2", PG_LATIN2
+	},
+	{
+		"ISO-8859-3", PG_LATIN3
+	},
+	{
+		"ISO-8859-4", PG_LATIN4
+	},
+	{
+		"ISO-8859-9", PG_LATIN5
+	},
+	{
+		"ISO-8859-10", PG_LATIN6
+	},
+	{
+		"ISO-8859-13", PG_LATIN7
+	},
+	{
+		"ISO-8859-14", PG_LATIN8
+	},
+	{
+		"ISO-8859-15", PG_LATIN9
+	},
+	{
+		"ISO-8859-16", PG_LATIN10
+	},
+	{
+		"windows-1256", PG_WIN1256
+	},
+	{
+		"windows-874", PG_WIN874
+	},
+	{
+		"KOI8-R", PG_KOI8R
+	},
+	{
+		"windows-1251", PG_WIN1251
+	},
+	{
+		"ISO-8859-5", PG_ISO_8859_5
+	},
+	{
+		"ISO-8859-6", PG_ISO_8859_6
+	},
+	{
+		"ISO-8859-7", PG_ISO_8859_7
+	},
+	{
+		"ISO-8859-8", PG_ISO_8859_8
+	},
+	{
+		"windows-1250", PG_WIN1250
+	},
+	{
+		"Shift_JIS", PG_SJIS
+	},
+	{
+		"Big5", PG_BIG5
+	},
+	{
+		"GBK", PG_GBK
+	},
+	{
+		"cp949", PG_UHC
+	},
+	{
+		"GB18030", PG_GB18030
+	}
+};
+#endif /* USE_ICU */
+
+
+
 /* ----------
  * Encoding checks, for error returns -1 else encoding id
  * ----------
--- src/backend/utils/mb/mbutils.c	2011-09-08 23:13:27.000000000 +0200
+++ src/backend/utils/mb/mbutils.c	2011-09-22 18:00:26.144329891 +0200
@@ -14,6 +14,9 @@
 #include "utils/builtins.h"
 #include "utils/memutils.h"
 #include "utils/syscache.h"
+#ifdef USE_ICU
+#include <unicode/ucnv.h>
+#endif /* USE_ICU */
 
 /*
  * When converting strings between different encodings, we assume that space
@@ -857,6 +860,9 @@
 
 	DatabaseEncoding = &pg_enc2name_tbl[encoding];
 	Assert(DatabaseEncoding->encoding == encoding);
+#ifdef USE_ICU
+	ucnv_setDefaultName((&pg_enc2iananame_tbl[encoding])->name);
+#endif
 }
 
 /*
--- src/include/pg_config.h.in	2011-09-08 23:13:27.000000000 +0200
+++ src/include/pg_config.h.in	2011-09-22 18:00:26.174439304 +0200
@@ -290,6 +290,12 @@
 /* Define to 1 if you have the `eay32' library (-leay32). */
 #undef HAVE_LIBEAY32
 
+/* Define to 1 if you have the `icui18n' library (-licui18n). */
+#undef HAVE_LIBICUI18N
+
+/* Define to 1 if you have the `icuuc' library (-licuuc). */
+#undef HAVE_LIBICUUC
+
 /* Define to 1 if you have the `ldap' library (-lldap). */
 #undef HAVE_LIBLDAP
 
@@ -759,6 +765,9 @@
 /* Define to 1 to build with Bonjour support. (--with-bonjour) */
 #undef USE_BONJOUR
 
+/* Define to build with ICU support. (--with-icu) */
+#undef USE_ICU
+
 /* Define to 1 if you want float4 values to be passed by value.
    (--enable-float4-byval) */
 #undef USE_FLOAT4_BYVAL
--- src/include/mb/pg_wchar.h.orig	2014-05-18 16:18:44.000000000 +0200
+++ src/include/mb/pg_wchar.h	2014-05-18 16:19:44.000000000 +0200
@@ -321,6 +321,10 @@
 
 extern const pg_enc2name pg_enc2name_tbl[];
 
+#ifdef USE_ICU
+extern pg_enc2name pg_enc2iananame_tbl[];
+#endif
+
 /*
  * Encoding names for gettext
  */
